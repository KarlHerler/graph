var searchIndex = {};
searchIndex['graphsearch'] = {"items":[[0,"","graphsearch","A [graph](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))\nrepresentation and search library",null,null],[3,"Node","","A node in the graph, made up a any content type `T` and a `Vec` of vertices",null,null],[12,"content","","content can be any type `T`",0,null],[12,"adjacent","","adjacent takes a `Vec` of vertices to adjacent nodes",0,null],[3,"Vertex","","A vertex between two `Node`s with an associated `i32` cost and a target node.\n`Vertex` derives `Copy`, `Debug`, `Eq` and `PartialEq` and implements `Ord` and\n`PartialOrd` as we use it ordered compound types.",null,null],[12,"cost","","cost is defiened as an `Ã¬32`, which might change",1,null],[12,"node","","node, an `usize` index of the node at the other end of this vertex",1,null],[3,"Graph","","A graph, represeted by as a weighted\n[Adjacency list](http://en.wikipedia.org/wiki/Adjacency_list) of `Node`s",null,null],[11,"fmt","","",1,{"inputs":[{"name":"vertex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"vertex"},{"name":"vertex"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"vertex"},{"name":"vertex"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"vertex"},{"name":"vertex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"vertex"},{"name":"vertex"}],"output":{"name":"option"}}],[11,"new","","`new` allows for initializing the graph struct with a given adjacency list",2,{"inputs":[{"name":"graph"},{"name":"vec"}],"output":{"name":"graph"}}],[11,"search","","`search` promises to use a correct method, i.e. one which will return the\n_best_ path between `start` and `target` if there is a valid path between them.\nWhich search method applied is not specified but currently Dijkstras algorithm\nis used. The path found is returned as a `VecDeque<usize>` of nodes. The\n`VecDeque<usize>` is an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"t"}],"output":{"name":"option"}}],[11,"search_using_index","","`search_using_index` promises to use a correct method, i.e. one which will\nreturn the _best_ path between the `start` index and `target` index if there\nis a valid path between them. Which search method applied is not specified but\ncurrently Dijkstras algorithm is used. The path found is returned as a\n`VecDeque<usize>` of nodes. The `VecDeque<usize>` is an optional type as there\nmight not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"breadth_first_search","","`breadth_first_search` implements breadth first search from `start` to the\n`target` and returns the path found as a `VecDeque<usize>` of nodes. This\nis an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"t"}],"output":{"name":"option"}}],[11,"breadth_first_search_using_index","","`breadth_first_search` implements breadth first search from the `start` index to the\n`target` and returns the path found as a `VecDeque<usize>` of nodes. This\nis an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"depth_first_search","","`depth_first_search` implements depth first search from `start` to the\n`target` and returns the path found as a `VecDeque<usize>` of nodes. This\nis an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"t"}],"output":{"name":"option"}}],[11,"depth_first_search_using_index","","`depth_first_search_using_index` implements depth first search from the `start`\nindex to the `target` index and returns the path found as a `VecDeque<usize>`\nof nodes. This is an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"dijkstra","","`dijkstra` implements Dijkstras algorithm for search from `start` to the\n`target` and returns the path found as a `VecDeque<usize>` of nodes. This\nis an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"t"}],"output":{"name":"option"}}],[11,"dijkstra_using_index","","`dijkstra_using_index` implements Dijkstras algorithm for search from the `start`\nindex to the `target` index and returns the path found as a `VecDeque<usize>`\nof nodes. This is an optional type as there might not be a path.",2,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"cost_of_path","","`cost_of_path` takes a path returned from any of the search functions and\ncalculates the cost of the path.",2,{"inputs":[{"name":"graph"},{"name":"vecdeque"}],"output":{"name":"i32"}}],[11,"node_to_index","","`node_to_index` takes an `Node` (from the graph) and returns its index, if\nit exists in the graph.",2,{"inputs":[{"name":"graph"},{"name":"node"}],"output":{"name":"option"}}],[11,"index_to_node","","`index_to_node` takes an index (from the graph) and returns the node at the\nindex, if the index is within the bounds of the graph. This is equivalent to\naccessing the underlying vector and thus is of **O(1)** complexity",2,{"inputs":[{"name":"graph"},{"name":"usize"}],"output":{"name":"option"}}]],"paths":[[3,"Node"],[3,"Vertex"],[3,"Graph"]]};
initSearch(searchIndex);
